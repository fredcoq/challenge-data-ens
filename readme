from seasons import seasonalize
arguments = {'mixed_columns': True, 'merge': True, 'pentecote': False, 'extradayoff': False, 
             'events' : {'world_cup_2014': ['12/06/2014', '13/07/2014'], 'rentree_2014': '02/09/2014', 'rentree_2015': '01/09/2015', 
                         'euro_cup_2016': ['10/06/2016', '10/07/2016'], 'rentree_2016': '01/09/2016', 'rentree_2017': '04/09/2017', 
                         'rentree_2018': '03/09/2018', 'world_cup_2018': ['14/06/2018', '15/07/2018']}}

df = seasonalize(y_RES1_BASE.loc[:date(2017,4,30)], **arguments).seasons_dataset()

# mixed_columns : False / True permet de générer soit les colonnes on_work / off_work / winter / summer quand c'est False 
# ou winter_on_work / winter_off_work / summer_on_work / summer_off_work quand c'est True

# merge : False / True permet de merger  les datasets de saisonalité avec celui des jours speciaux avec le dataset fourni en entrée

# pentecote : False / True permet de gérer le jeudi de pentecote comme un jour ouvré par défaut ou férié

# extradayoff : False / True permet de gérer les jours de pont comme étant férié

# events : dict de clé / valeur (la clé n'est pas réellement gérer, a part pour dupprimer une entrée dans le dictionaire, 
# pour les jours speciaux sur plusieurs jours, il suffit de mettre  une liste avec le 1er jour et le dernier jour de 
# l'evenement, le programe se chargera de générer les jours entre ces deux dates comme fesant partie de l'événement.

# Il y a 5 classes : 
# seasonalize : la classe principale, c'est le point d'entrée, permet de gérer les dataframes et de générer les dataframes de sortie.
# holydays : la classe permettant de gérer les jours ouvrés et les jours fériés
# solstice : la classe permettant de gérer les solstices d'hivers et d'été
# special_days : la classe permettant de générer et de manipuler le dictionnaire des évenements spéciaux
# clock : la classe qui gére les dates et le timezone
